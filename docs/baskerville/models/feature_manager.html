<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
  <meta content="pdoc 0.7.2" name="generator"/>
  <title>
   baskerville.models.feature_manager API documentation
  </title>
  <meta content="" name="description"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet"/>
  <style>
   .flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}
  </style>
  <style media="screen and (min-width: 700px)">
   @media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}
  </style>
  <style media="print">
   @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}
  </style>
 </head>
 <body>
  <main>
   <article id="content">
    <header>
     <h1 class="title">
      Module
      <code>
       baskerville.models.feature_manager
      </code>
     </h1>
    </header>
    <section id="section-intro">
     <details class="source">
      <summary>
       <span>
        Expand source code
       </span>
      </summary>
      <pre><code class="python"># Copyright (c) 2020, eQualit.ie inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.


import itertools
from collections import OrderedDict

from baskerville.features.helpers import feature_is_updateable
from baskerville.util.helpers import get_logger


class FeatureManager(object):
    def __init__(
            self,
            engine_conf
    ):
        self.all_features = engine_conf.all_features
        self.extra_features = engine_conf.extra_features
        self.active_features = None
        self.active_feature_names = None
        self.updateable_active_features = None
        self.active_columns = None
        self.update_feature_cols = None
        self.column_renamings = None
        self.pre_group_by_calculations = None
        self.post_group_by_calculations = None

        self.logger = get_logger(
            self.__class__.__name__,
            logging_level=engine_conf.log_level,
            output_file=engine_conf.logpath
        )

    def initialize(self,):
        self.active_features = self.get_active_features()
        self.active_feature_names = self.get_active_feature_names()
        self.updateable_active_features = self.get_updateable_active_features()
        self.active_columns = self.get_active_columns()
        self.update_feature_cols = self.get_update_feature_columns()
        self.column_renamings = self.get_feature_col_renamings()
        self.pre_group_by_calculations = self.get_feature_pre_group_by_calcs()
        self.post_group_by_calculations = self.get_post_group_by_calculations()

    def get_active_features(self):
        """
        Returns a list of the active feature instances
        :return:
        """
        feature_list = self.extra_features
        if not feature_list:
            raise RuntimeError('No features specified! Either input model '
                               'or specify features in config.')

        feature_list = set(feature_list)
        diff = feature_list.difference(self.all_features.keys())
        if diff:
            self.logger.warn(
                f'Warning: omitting unknown features {diff}.'
            )
        features_to_use = [f for n, f in self.all_features.items()
                           if n in feature_list]
        dependencies = list(set(
            f for f in itertools.chain(
                *[f.DEPENDENCIES for f in features_to_use]  # todo class attr
            )
        ))
        features_to_use += dependencies
        features_to_use = set(features_to_use)
        return list(set([f() for f in features_to_use]))

    def get_active_feature_names(self) -&gt; list:
        """
        Returns a list of the active feature names
        :return:
        """
        return [f.feature_name for f in self.active_features]

    def get_updateable_active_features(self) -&gt; list:
        """
        Returns a list of the updateable features
        :return:
        """
        return [
            f for f in self.active_features
            if feature_is_updateable(f)
        ]

    def get_active_columns(self) -&gt; list:
        """
        returns a list of the column names that need to be in the logs df
        :return:
        :rtype:list[str]
        """
        return list(
            set(
                itertools.chain(
                    *[feature.columns for feature in self.active_features]
                )
            )
        )

    def get_update_feature_columns(self) -&gt; list:
        """
        Returns the names for the updated features
        :return:
        """
        return [
            f.updated_feature_col_name for f in self.active_features
            if feature_is_updateable(f)
        ]

    def feature_config_is_valid(self) -&gt; bool:
        """
        Returns False if any of the feature checks fail and True otherwise.
        If there is no model, then we don't do feature checks. The reason
        behind this is because we want to distinguish whether we cannot predict
        because we're missing the ml model or because the feature configuration
        is not valid.
        :return:
        """
        checks = []
        checks.append(self.feature_dependencies_met())

        return False not in checks

    def feature_dependencies_met(self) -&gt; bool:
        """
        Checks that the features defined as dependencies are included in the
        active features list
        :return: True if all feature dependencies are met, False otherwise
        :rtype: bool
        """
        required_features = set(itertools.chain(
            *[feature.dependencies for feature in self.active_features])
        )
        return set(
            [f.feature_name_from_class() for f in required_features]
        ).issubset(set(self.active_feature_names))

    def get_feature_pre_group_by_calcs(self) -&gt; dict:
        """
        Gather all the calculations that need to be applied on the logs_df
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        aggs = OrderedDict()

        for f in self.active_features:
            for k, v in f.pre_group_by_calcs.items():
                if k not in aggs:
                    aggs[k] = (v).alias(k)

        return aggs

    def get_feature_group_by_aggs(self) -&gt; dict:
        """
        Gather all the aggregations that need to be applied to the grouped
        dataframe
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        aggs = OrderedDict()

        for f in self.active_features:
            for k, v in f.group_by_aggs.items():
                if k not in aggs:
                    aggs[k] = (v).alias(k)

        return aggs

    def get_feature_col_renamings(self) -&gt; list:
        """
        Gather all the column renamings that need to be applied on the logs_df
        :return:
        :rtype: list[tuple(str, pyspark.sql.Column)]
        """
        renamings = []

        for f in self.active_features:
            for k, v in f.columns_renamed.items():
                if (k, v) not in renamings:
                    renamings.append((k, v))
                else:
                    self.logger.warn(f'Duplicate column renaming {k} to {v}')

        return renamings

    def get_post_group_by_calculations(self) -&gt; dict:
        """
        Gather all the post group by calculations that are defined by the
        features
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        post_group_by_columns = {}

        for feature in self.active_features:
            for k, v in feature.post_group_by_calcs.items():
                if k not in post_group_by_columns:
                    post_group_by_columns[k] = v
                else:
                    self.logger.debug(f'{k} is already in the dataframe.')

        return post_group_by_columns</code></pre>
     </details>
    </section>
    <section>
    </section>
    <section>
    </section>
    <section>
    </section>
    <section>
     <h2 class="section-title" id="header-classes">
      Classes
     </h2>
     <dl>
      <dt id="baskerville.models.feature_manager.FeatureManager">
       <code class="flex name class">
        <span>
         class
         <span class="ident">
          FeatureManager
         </span>
        </span>
        <span>
         (
        </span>
        <span>
         engine_conf)
        </span>
       </code>
      </dt>
      <dd>
       <section class="desc">
       </section>
       <details class="source">
        <summary>
         <span>
          Expand source code
         </span>
        </summary>
        <pre><code class="python">class FeatureManager(object):
    def __init__(
            self,
            engine_conf
    ):
        self.all_features = engine_conf.all_features
        self.extra_features = engine_conf.extra_features
        self.active_features = None
        self.active_feature_names = None
        self.updateable_active_features = None
        self.active_columns = None
        self.update_feature_cols = None
        self.column_renamings = None
        self.pre_group_by_calculations = None
        self.post_group_by_calculations = None

        self.logger = get_logger(
            self.__class__.__name__,
            logging_level=engine_conf.log_level,
            output_file=engine_conf.logpath
        )

    def initialize(self,):
        self.active_features = self.get_active_features()
        self.active_feature_names = self.get_active_feature_names()
        self.updateable_active_features = self.get_updateable_active_features()
        self.active_columns = self.get_active_columns()
        self.update_feature_cols = self.get_update_feature_columns()
        self.column_renamings = self.get_feature_col_renamings()
        self.pre_group_by_calculations = self.get_feature_pre_group_by_calcs()
        self.post_group_by_calculations = self.get_post_group_by_calculations()

    def get_active_features(self):
        """
        Returns a list of the active feature instances
        :return:
        """
        feature_list = self.extra_features
        if not feature_list:
            raise RuntimeError('No features specified! Either input model '
                               'or specify features in config.')

        feature_list = set(feature_list)
        diff = feature_list.difference(self.all_features.keys())
        if diff:
            self.logger.warn(
                f'Warning: omitting unknown features {diff}.'
            )
        features_to_use = [f for n, f in self.all_features.items()
                           if n in feature_list]
        dependencies = list(set(
            f for f in itertools.chain(
                *[f.DEPENDENCIES for f in features_to_use]  # todo class attr
            )
        ))
        features_to_use += dependencies
        features_to_use = set(features_to_use)
        return list(set([f() for f in features_to_use]))

    def get_active_feature_names(self) -&gt; list:
        """
        Returns a list of the active feature names
        :return:
        """
        return [f.feature_name for f in self.active_features]

    def get_updateable_active_features(self) -&gt; list:
        """
        Returns a list of the updateable features
        :return:
        """
        return [
            f for f in self.active_features
            if feature_is_updateable(f)
        ]

    def get_active_columns(self) -&gt; list:
        """
        returns a list of the column names that need to be in the logs df
        :return:
        :rtype:list[str]
        """
        return list(
            set(
                itertools.chain(
                    *[feature.columns for feature in self.active_features]
                )
            )
        )

    def get_update_feature_columns(self) -&gt; list:
        """
        Returns the names for the updated features
        :return:
        """
        return [
            f.updated_feature_col_name for f in self.active_features
            if feature_is_updateable(f)
        ]

    def feature_config_is_valid(self) -&gt; bool:
        """
        Returns False if any of the feature checks fail and True otherwise.
        If there is no model, then we don't do feature checks. The reason
        behind this is because we want to distinguish whether we cannot predict
        because we're missing the ml model or because the feature configuration
        is not valid.
        :return:
        """
        checks = []
        checks.append(self.feature_dependencies_met())

        return False not in checks

    def feature_dependencies_met(self) -&gt; bool:
        """
        Checks that the features defined as dependencies are included in the
        active features list
        :return: True if all feature dependencies are met, False otherwise
        :rtype: bool
        """
        required_features = set(itertools.chain(
            *[feature.dependencies for feature in self.active_features])
        )
        return set(
            [f.feature_name_from_class() for f in required_features]
        ).issubset(set(self.active_feature_names))

    def get_feature_pre_group_by_calcs(self) -&gt; dict:
        """
        Gather all the calculations that need to be applied on the logs_df
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        aggs = OrderedDict()

        for f in self.active_features:
            for k, v in f.pre_group_by_calcs.items():
                if k not in aggs:
                    aggs[k] = (v).alias(k)

        return aggs

    def get_feature_group_by_aggs(self) -&gt; dict:
        """
        Gather all the aggregations that need to be applied to the grouped
        dataframe
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        aggs = OrderedDict()

        for f in self.active_features:
            for k, v in f.group_by_aggs.items():
                if k not in aggs:
                    aggs[k] = (v).alias(k)

        return aggs

    def get_feature_col_renamings(self) -&gt; list:
        """
        Gather all the column renamings that need to be applied on the logs_df
        :return:
        :rtype: list[tuple(str, pyspark.sql.Column)]
        """
        renamings = []

        for f in self.active_features:
            for k, v in f.columns_renamed.items():
                if (k, v) not in renamings:
                    renamings.append((k, v))
                else:
                    self.logger.warn(f'Duplicate column renaming {k} to {v}')

        return renamings

    def get_post_group_by_calculations(self) -&gt; dict:
        """
        Gather all the post group by calculations that are defined by the
        features
        :return:
        :rtype: dict[str, pyspark.sql.Column]
        """
        post_group_by_columns = {}

        for feature in self.active_features:
            for k, v in feature.post_group_by_calcs.items():
                if k not in post_group_by_columns:
                    post_group_by_columns[k] = v
                else:
                    self.logger.debug(f'{k} is already in the dataframe.')

        return post_group_by_columns</code></pre>
       </details>
       <h3>
        Methods
       </h3>
       <dl>
        <dt id="baskerville.models.feature_manager.FeatureManager.feature_config_is_valid">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            feature_config_is_valid
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns False if any of the feature checks fail and True otherwise.
If there is no model, then we don't do feature checks. The reason
behind this is because we want to distinguish whether we cannot predict
because we're missing the ml model or because the feature configuration
is not valid.
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def feature_config_is_valid(self) -&gt; bool:
    """
    Returns False if any of the feature checks fail and True otherwise.
    If there is no model, then we don't do feature checks. The reason
    behind this is because we want to distinguish whether we cannot predict
    because we're missing the ml model or because the feature configuration
    is not valid.
    :return:
    """
    checks = []
    checks.append(self.feature_dependencies_met())

    return False not in checks</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.feature_dependencies_met">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            feature_dependencies_met
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Checks that the features defined as dependencies are included in the
active features list
:return: True if all feature dependencies are met, False otherwise
:rtype: bool
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def feature_dependencies_met(self) -&gt; bool:
    """
    Checks that the features defined as dependencies are included in the
    active features list
    :return: True if all feature dependencies are met, False otherwise
    :rtype: bool
    """
    required_features = set(itertools.chain(
        *[feature.dependencies for feature in self.active_features])
    )
    return set(
        [f.feature_name_from_class() for f in required_features]
    ).issubset(set(self.active_feature_names))</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_active_columns">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_active_columns
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           returns a list of the column names that need to be in the logs df
:return:
:rtype:list[str]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_active_columns(self) -&gt; list:
    """
    returns a list of the column names that need to be in the logs df
    :return:
    :rtype:list[str]
    """
    return list(
        set(
            itertools.chain(
                *[feature.columns for feature in self.active_features]
            )
        )
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_active_feature_names">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_active_feature_names
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns a list of the active feature names
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_active_feature_names(self) -&gt; list:
    """
    Returns a list of the active feature names
    :return:
    """
    return [f.feature_name for f in self.active_features]</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_active_features">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_active_features
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns a list of the active feature instances
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_active_features(self):
    """
    Returns a list of the active feature instances
    :return:
    """
    feature_list = self.extra_features
    if not feature_list:
        raise RuntimeError('No features specified! Either input model '
                           'or specify features in config.')

    feature_list = set(feature_list)
    diff = feature_list.difference(self.all_features.keys())
    if diff:
        self.logger.warn(
            f'Warning: omitting unknown features {diff}.'
        )
    features_to_use = [f for n, f in self.all_features.items()
                       if n in feature_list]
    dependencies = list(set(
        f for f in itertools.chain(
            *[f.DEPENDENCIES for f in features_to_use]  # todo class attr
        )
    ))
    features_to_use += dependencies
    features_to_use = set(features_to_use)
    return list(set([f() for f in features_to_use]))</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_feature_col_renamings">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_feature_col_renamings
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Gather all the column renamings that need to be applied on the logs_df
:return:
:rtype: list[tuple(str, pyspark.sql.Column)]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_feature_col_renamings(self) -&gt; list:
    """
    Gather all the column renamings that need to be applied on the logs_df
    :return:
    :rtype: list[tuple(str, pyspark.sql.Column)]
    """
    renamings = []

    for f in self.active_features:
        for k, v in f.columns_renamed.items():
            if (k, v) not in renamings:
                renamings.append((k, v))
            else:
                self.logger.warn(f'Duplicate column renaming {k} to {v}')

    return renamings</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_feature_group_by_aggs">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_feature_group_by_aggs
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Gather all the aggregations that need to be applied to the grouped
dataframe
:return:
:rtype: dict[str, pyspark.sql.Column]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_feature_group_by_aggs(self) -&gt; dict:
    """
    Gather all the aggregations that need to be applied to the grouped
    dataframe
    :return:
    :rtype: dict[str, pyspark.sql.Column]
    """
    aggs = OrderedDict()

    for f in self.active_features:
        for k, v in f.group_by_aggs.items():
            if k not in aggs:
                aggs[k] = (v).alias(k)

    return aggs</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_feature_pre_group_by_calcs">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_feature_pre_group_by_calcs
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Gather all the calculations that need to be applied on the logs_df
:return:
:rtype: dict[str, pyspark.sql.Column]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_feature_pre_group_by_calcs(self) -&gt; dict:
    """
    Gather all the calculations that need to be applied on the logs_df
    :return:
    :rtype: dict[str, pyspark.sql.Column]
    """
    aggs = OrderedDict()

    for f in self.active_features:
        for k, v in f.pre_group_by_calcs.items():
            if k not in aggs:
                aggs[k] = (v).alias(k)

    return aggs</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_post_group_by_calculations">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_post_group_by_calculations
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Gather all the post group by calculations that are defined by the
features
:return:
:rtype: dict[str, pyspark.sql.Column]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_post_group_by_calculations(self) -&gt; dict:
    """
    Gather all the post group by calculations that are defined by the
    features
    :return:
    :rtype: dict[str, pyspark.sql.Column]
    """
    post_group_by_columns = {}

    for feature in self.active_features:
        for k, v in feature.post_group_by_calcs.items():
            if k not in post_group_by_columns:
                post_group_by_columns[k] = v
            else:
                self.logger.debug(f'{k} is already in the dataframe.')

    return post_group_by_columns</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_update_feature_columns">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_update_feature_columns
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns the names for the updated features
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_update_feature_columns(self) -&gt; list:
    """
    Returns the names for the updated features
    :return:
    """
    return [
        f.updated_feature_col_name for f in self.active_features
        if feature_is_updateable(f)
    ]</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.get_updateable_active_features">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_updateable_active_features
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns a list of the updateable features
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_updateable_active_features(self) -&gt; list:
    """
    Returns a list of the updateable features
    :return:
    """
    return [
        f for f in self.active_features
        if feature_is_updateable(f)
    ]</code></pre>
         </details>
        </dd>
        <dt id="baskerville.models.feature_manager.FeatureManager.initialize">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            initialize
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def initialize(self,):
    self.active_features = self.get_active_features()
    self.active_feature_names = self.get_active_feature_names()
    self.updateable_active_features = self.get_updateable_active_features()
    self.active_columns = self.get_active_columns()
    self.update_feature_cols = self.get_update_feature_columns()
    self.column_renamings = self.get_feature_col_renamings()
    self.pre_group_by_calculations = self.get_feature_pre_group_by_calcs()
    self.post_group_by_calculations = self.get_post_group_by_calculations()</code></pre>
         </details>
        </dd>
       </dl>
      </dd>
     </dl>
    </section>
   </article>
   <nav id="sidebar">
    <h1>
     Index
    </h1>
    <div class="toc">
     <ul>
     </ul>
    </div>
    <ul id="index">
     <li>
      <h3>
       Super-module
      </h3>
      <ul>
       <li>
        <code>
         <a href="index.html" title="baskerville.models">
          baskerville.models
         </a>
        </code>
       </li>
      </ul>
     </li>
     <li>
      <h3>
       <a href="#header-classes">
        Classes
       </a>
      </h3>
      <ul>
       <li>
        <h4>
         <code>
          <a href="#baskerville.models.feature_manager.FeatureManager" title="baskerville.models.feature_manager.FeatureManager">
           FeatureManager
          </a>
         </code>
        </h4>
        <ul class="">
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.feature_config_is_valid" title="baskerville.models.feature_manager.FeatureManager.feature_config_is_valid">
            feature_config_is_valid
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.feature_dependencies_met" title="baskerville.models.feature_manager.FeatureManager.feature_dependencies_met">
            feature_dependencies_met
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_active_columns" title="baskerville.models.feature_manager.FeatureManager.get_active_columns">
            get_active_columns
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_active_feature_names" title="baskerville.models.feature_manager.FeatureManager.get_active_feature_names">
            get_active_feature_names
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_active_features" title="baskerville.models.feature_manager.FeatureManager.get_active_features">
            get_active_features
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_feature_col_renamings" title="baskerville.models.feature_manager.FeatureManager.get_feature_col_renamings">
            get_feature_col_renamings
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_feature_group_by_aggs" title="baskerville.models.feature_manager.FeatureManager.get_feature_group_by_aggs">
            get_feature_group_by_aggs
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_feature_pre_group_by_calcs" title="baskerville.models.feature_manager.FeatureManager.get_feature_pre_group_by_calcs">
            get_feature_pre_group_by_calcs
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_post_group_by_calculations" title="baskerville.models.feature_manager.FeatureManager.get_post_group_by_calculations">
            get_post_group_by_calculations
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_update_feature_columns" title="baskerville.models.feature_manager.FeatureManager.get_update_feature_columns">
            get_update_feature_columns
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.get_updateable_active_features" title="baskerville.models.feature_manager.FeatureManager.get_updateable_active_features">
            get_updateable_active_features
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.models.feature_manager.FeatureManager.initialize" title="baskerville.models.feature_manager.FeatureManager.initialize">
            initialize
           </a>
          </code>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </nav>
  </main>
  <footer id="footer">
   <p>
    Generated by
    <a href="https://pdoc3.github.io/pdoc">
     <cite>
      pdoc
     </cite>
     0.7.2
    </a>
    .
   </p>
   <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">
    <img alt="Creative Commons Licence" src="https://i.creativecommons.org/l/by/4.0/80x15.png" style="border-width:0"/>
   </a>
   <br/>
   This work is copyright (c) 2020, eQualit.ie inc., and is licensed under a
   <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">
    Creative Commons Attribution 4.0 International License
   </a>
   .
  </footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad()
  </script>
 </body>
</html>