<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
  <meta content="pdoc 0.7.2" name="generator"/>
  <title>
   baskerville.db.temporal_partition API documentation
  </title>
  <meta content="" name="description"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css" rel="stylesheet"/>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet"/>
  <style>
   .flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}
  </style>
  <style media="screen and (min-width: 700px)">
   @media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}
  </style>
  <style media="print">
   @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}
  </style>
 </head>
 <body>
  <main>
   <article id="content">
    <header>
     <h1 class="title">
      Module
      <code>
       baskerville.db.temporal_partition
      </code>
     </h1>
    </header>
    <section id="section-intro">
     <details class="source">
      <summary>
       <span>
        Expand source code
       </span>
      </summary>
      <pre><code class="python"># Copyright (c) 2020, eQualit.ie inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree.


from datetime import datetime, timedelta
from collections import defaultdict
import isoweek
from dateutil.tz import tzutc
from baskerville.util.enums import PartitionByEnum
from baskerville.util.helpers import get_days_in_year, get_days_in_month
from baskerville.db.base import PartitionedTable, Partition, TableTools, Index
from es_retriever.helpers.time_period import TimePeriod as TP


class TimePeriod(TP):
    """
    Extends es_retriever.helpers.time_period.TimePeriod
    """

    def __init__(self, start, end, utc=True):
        super().__init__(start, end)
        self.utc = utc
        if self.utc:
            self.start = self.start.replace(
                tzinfo=tzutc()
            ).replace(microsecond=0)
            self.end = self.end.replace(
                tzinfo=tzutc()
            ).replace(microsecond=999999)

    def __gt__(self, other):
        return self.start &gt; other.start

    def __ge__(self, other):
        return self.start &gt;= other.start

    def __le__(self, other):
        return self.start &lt;= other.start

    def __lt__(self, other):
        return self.start &lt; other.start

    def split_by_year(self) -&gt; list:
        """
        Splits current time period by year
        :return: a list of time periods, each one of them has a start and end
        in a different year,
         e.g. [ TimePeriod(01-01-2018, 31-12-2018),
                TimePeriod(01-01-2019, 31-01-2019)
            ]
        """
        if self.start.year == self.end.year:
            return [self]

        days_in_year = get_days_in_year(self.start.year)
        start = self.start
        end = start + timedelta(days=days_in_year - start.timetuple().tm_yday)
        sub_periods = []

        while end &lt;= self.end:
            sub_periods.append(TimePeriod(start, end))
            days_in_year = get_days_in_year(start.year)
            start = end
            if start.year == self.end.year:
                end = self.end
            else:
                end = start + timedelta(days=days_in_year)

        return sub_periods

    def split_by_year_and_month(self, strict=False) -&gt; dict:
        """
        Splits the current time period by year and by month.
        E.g.:
        {
            2017: {
                12: TimePeriod instance
            },
            2018: {
                1: TimePeriod instance
            }
        }
        :param bool strict: finish at the end of the month (False), or exactly
        at the end date
        :return:
        """
        days_in_end_month = get_days_in_month(self.end.year, self.end.month)
        start_m = self.start
        end_m = self.end
        if not strict:
            start_m = self.start.replace(day=1, hour=0, minute=0, second=0)
            end_m = self.end.replace(
                day=days_in_end_month,
                hour=23,
                minute=59,
                second=59
            )

        if self.start.year == self.end.year:
            if self.start.month == self.end.month:
                if strict:
                    return {
                        self.start.year: {
                            self.start.month: TimePeriod(
                                start_m,
                                end_m
                            )
                        }
                    }
                return {
                    self.start.year: {self.start.month: self}
                }

        sub_periods = {}

        for year_tw in self.split_by_year():
            y = year_tw.start.year
            m = year_tw.start.month
            days_in_month = get_days_in_month(self.start.year,
                                              self.start.month)
            start = year_tw.start
            end = start.replace(
                day=days_in_month,
                hour=23,
                minute=59,
                second=59,
                microsecond=59
            )
            curr_period = {y: defaultdict(list)}
            for i in range(m, 13):
                curr_period[y][i].append(TimePeriod(start, end))
                start = datetime(y, i, 1, 0, 0, 0, 0).replace(tzinfo=tzutc())
                days_in_month = get_days_in_month(start.year, i)
                if i == self.end.month and strict:
                    end = self.end
                else:
                    end = start.replace(
                        day=days_in_month,
                        hour=23,
                        minute=59,
                        second=59,
                        microsecond=59
                    )
            sub_periods.update(curr_period)

        print(sub_periods)
        return sub_periods

    def split_by_year_and_week(self, strict=False) -&gt; dict:
        """
        Splits the current time period by year and by week.
        E.g.:
        {
            2017: {
                52: TimePeriod instance
            },
            2018: {
                0: TimePeriod instance
            }
        }
        :param bool strict: finish at the end of the week (False), or exactly
        at the end date
        :return:
        """
        sub_periods = {}
        start_y, start_w, _ = self.start.isocalendar()
        end_y, end_w, _ = self.end.isocalendar()

        if start_y == end_y and start_w == end_y:
            if strict:
                return {
                    start_y: {start_w: self}
                }
            else:
                week = isoweek.Week(start_y, start_w)
                start_wd = datetime(*week.monday().timetuple()[:6]).replace(
                    hour=0, minute=0, second=0
                )
                end_wd = datetime(*week.sunday().timetuple()[:6]).replace(
                    hour=23, minute=59, second=59
                )
                return {
                    start_y: {start_w: TimePeriod(
                        start_wd,
                        end_wd
                    )}
                }

        for year_tw in self.split_by_year():
            start_range = 0
            y = year_tw.start.year
            curr_period = {y: defaultdict(list)}
            weeks_in_year = isoweek.Week.last_week_of_year(y).week

            if y == self.end.year and y == end_y:
                weeks_in_year = self.end.isocalendar()[1]

            if y == self.start.year and y == start_y:
                start_range = self.start.isocalendar()[1]

            for w in range(start_range, weeks_in_year + 1):
                week = isoweek.Week(y, w)
                if y == self.start.year and w == start_range and strict:
                    start = self.start
                else:
                    start = datetime(
                        *week.monday().timetuple()[:6]
                    ).replace(hour=0, minute=0, second=0)
                    if y == self.start.year and y == start_y and w == start_range:
                        start = start.replace(
                            hour=self.start.hour,
                            minute=self.start.minute,
                            second=self.start.second
                        )
                if y == self.end.year and w == end_w and strict:
                    end = self.end
                else:
                    end = datetime(
                        *week.sunday().timetuple()[:6]
                    ).replace(hour=23, minute=59, second=59)
                curr_period[y][w] = TimePeriod(start, end)
            sub_periods.update(curr_period)

            if end_y not in sub_periods:
                week = isoweek.Week(end_y, end_w)
                start = datetime(
                    *week.monday().timetuple()[:6]).replace(
                    hour=0, minute=0, second=0
                )
                end = self.end
                if not strict:
                    end = datetime(*week.sunday().timetuple()[:6]).replace(
                        hour=23, minute=59, second=59)
                sub_periods[end_y] = {end_w: TimePeriod(start, end)}

        return sub_periods


class TemporalPartitionedTable(PartitionedTable):
    """
    Representation of a partitioned by date table.
    """

    def __init__(
            self, name, active_period, partition_field,
            partitioned_by=PartitionByEnum.w, index_by=None,
            create_catch_all=True, strict=False
    ):
        super().__init__(
            name, partition_field, partitioned_by, index_by, create_catch_all
        )
        self.strict = strict
        self.active_period = active_period
        self._partition_prefix = self.get_partition_prefix()
        self.start_year = self.active_period.start.year

    @property
    def partition_prefix(self):
        """
        The prefix of the partitioned table e.g.
        :return:
        """
        return self._partition_prefix.replace(
            '%year', str(self.active_period.start.year)
        ).replace('%unit', '')

    @property
    def start(self):
        if self.partitions:
            return min(self.partitions).active_period.start
        return self.active_period.start

    @property
    def end(self):
        if self.partitions:
            p = max(self.partitions)
            if p.is_catch_all:
                p = self.partitions[-2]
            return p.active_period.end
        return self.active_period.end

    def self_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.start,
            self.end,
            new=True
        )

    @property
    def field_value(self) -&gt; str:
        return f'cast(extract({self.partitioned_by} ' \
            f'from NEW.{self.partition_field}) AS TEXT)'

    def get_partition_prefix(self) -&gt; str:
        """
        The table prefix, in the form of:
        table_to_be_partitioned_%unit
        where unit will be replaced by the partition type
        (year, month, week etc)
        :return:
        """
        return f'{self.name}_y%year_{str(self.partitioned_by)[0]}%unit'

    def get_partition_name(self, year, unit) -&gt; str:
        return self._partition_prefix.replace(
            '%year', str(year)
        ).replace(
            '%unit', str(unit)
        )

    def get_partition_range(self) -&gt; dict:
        """
        Return a dict with the date range for the partitions
        e.g.
        for the weekly partition:
         {
            2017: {
                52: TimePeriod instance
            },
            2018: {
                0: TimePeriod instance
            }
        }
        :return:
        :rtype: dict[int][TimePeriod]
        """
        if self.partitioned_by == PartitionByEnum.w:
            return self.active_period.split_by_year_and_week(self.strict)
        elif self.partitioned_by == PartitionByEnum.m:
            return self.active_period.split_by_year_and_month(self.strict)
        else:
            raise ValueError(
                f'Unknown split by option {str(self.partitioned_by)}')

    def partition(self) -&gt; list:
        """
        Partition the table by the partition range
        :return: A list of partitions to be created
        :rtype: list[TemporalPartition]
        """
        for y, units in self.get_partition_range().items():
            for i, tw in units.items():
                self.partitions.append(self.get_partition_for(i, tw, y))
        if self.create_catch_all:
            self.partitions.append(self.get_catch_all_partition())

        return sorted(self.partitions, key=lambda p: p.active_period)

    def get_partition_for(self, unit, tw, year):
        """
        Returns a TemporalPartition for the specific time period (tw) and year
        - given a unit: month | week
        :param str unit: m (for month) or w (for week)
        :param TimePeriod tw:
        :param int year:
        :return:
        :rtype: TemporalPartition
        """
        return TemporalPartition(
            self.get_partition_name(year, unit),
            tw,
            self.partition_field,
            self.index_by
        )

    def get_catch_all_partition(self):
        """
        Create a TemporalPartition that will serve as a catch all partition
        :return:
        :rtype: TemporalPartition
        """
        start = self.end + timedelta(seconds=1)
        end = self.start - timedelta(seconds=1)
        return TemporalPartition(
            self.catch_all_partition_name,
            TimePeriod(start, end),
            self.partition_field,
            self.index_by,
            is_catch_all=True
        )

    def to_dict(self):
        return {
            'name': self.name,
            'partition_prefix': self.partition_prefix,
            'partitions': [p.to_dict() for p in self.partitions],
            'catch_all_partition_name': self.catch_all_partition_name,
            'partitioned_by': str(self.partitioned_by),
            'partition_field': self.partition_field,
            'field_value': self.field_value,
            'self_check': self.self_check()
        }


class TemporalPartition(Partition):
    def __init__(self, name, active_period, partition_field, index_by=None,
                 is_catch_all=False):
        super().__init__(name, partition_field, index_by, is_catch_all)
        self.name = name
        self.active_period = active_period
        self.partition_field = partition_field
        self.index_by = index_by
        self.indexes = []

    def __lt__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &lt; other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &lt; other

    def __le__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &lt;= other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &lt;= other

    def __gt__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &gt; other.active_period
        if isinstance(other, datetime):
            return self.active_period.end &gt; other

    def __ge__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &gt;= other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &gt;= other

    @property
    def constraint_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.active_period.start,
            self.active_period.end,
            new=False
        )

    @property
    def self_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.active_period.start,
            self.active_period.end,
            new=False
        )

    @property
    def index(self):
        if self.index_by:
            return Index(
                f'idx_{self.name}_{"_".join(self.index_by)}',
                self.name,
                self.index_by
            )

    def to_dict(self):
        return {
            'name': self.name,
            'start': self.active_period.start,
            'end': self.active_period.end,
            'constraint_check': self.constraint_check,
            'self_check': self.self_check,
            'is_catch_all': self.is_catch_all,
            'indexes': [self.index.to_dict()] if self.index else [],
            # todo: single index support for now
        }</code></pre>
     </details>
    </section>
    <section>
    </section>
    <section>
    </section>
    <section>
    </section>
    <section>
     <h2 class="section-title" id="header-classes">
      Classes
     </h2>
     <dl>
      <dt id="baskerville.db.temporal_partition.TemporalPartition">
       <code class="flex name class">
        <span>
         class
         <span class="ident">
          TemporalPartition
         </span>
        </span>
        <span>
         (
        </span>
        <span>
         name, active_period, partition_field, index_by=None, is_catch_all=False)
        </span>
       </code>
      </dt>
      <dd>
       <section class="desc">
       </section>
       <details class="source">
        <summary>
         <span>
          Expand source code
         </span>
        </summary>
        <pre><code class="python">class TemporalPartition(Partition):
    def __init__(self, name, active_period, partition_field, index_by=None,
                 is_catch_all=False):
        super().__init__(name, partition_field, index_by, is_catch_all)
        self.name = name
        self.active_period = active_period
        self.partition_field = partition_field
        self.index_by = index_by
        self.indexes = []

    def __lt__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &lt; other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &lt; other

    def __le__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &lt;= other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &lt;= other

    def __gt__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &gt; other.active_period
        if isinstance(other, datetime):
            return self.active_period.end &gt; other

    def __ge__(self, other):
        if isinstance(other, TemporalPartition):
            return self.active_period &gt;= other.active_period
        if isinstance(other, datetime):
            return self.active_period.start &gt;= other

    @property
    def constraint_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.active_period.start,
            self.active_period.end,
            new=False
        )

    @property
    def self_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.active_period.start,
            self.active_period.end,
            new=False
        )

    @property
    def index(self):
        if self.index_by:
            return Index(
                f'idx_{self.name}_{"_".join(self.index_by)}',
                self.name,
                self.index_by
            )

    def to_dict(self):
        return {
            'name': self.name,
            'start': self.active_period.start,
            'end': self.active_period.end,
            'constraint_check': self.constraint_check,
            'self_check': self.self_check,
            'is_catch_all': self.is_catch_all,
            'indexes': [self.index.to_dict()] if self.index else [],
            # todo: single index support for now
        }</code></pre>
       </details>
       <h3>
        Ancestors
       </h3>
       <ul class="hlist">
        <li>
         <a href="base.html#baskerville.db.base.Partition" title="baskerville.db.base.Partition">
          Partition
         </a>
        </li>
       </ul>
       <h3>
        Instance variables
       </h3>
       <dl>
        <dt id="baskerville.db.temporal_partition.TemporalPartition.constraint_check">
         <code class="name">
          var
          <span class="ident">
           constraint_check
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def constraint_check(self):
    return TableTools.get_temporal_check(
        self.partition_field,
        self.active_period.start,
        self.active_period.end,
        new=False
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartition.index">
         <code class="name">
          var
          <span class="ident">
           index
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def index(self):
    if self.index_by:
        return Index(
            f'idx_{self.name}_{"_".join(self.index_by)}',
            self.name,
            self.index_by
        )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartition.self_check">
         <code class="name">
          var
          <span class="ident">
           self_check
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def self_check(self):
    return TableTools.get_temporal_check(
        self.partition_field,
        self.active_period.start,
        self.active_period.end,
        new=False
    )</code></pre>
         </details>
        </dd>
       </dl>
       <h3>
        Methods
       </h3>
       <dl>
        <dt id="baskerville.db.temporal_partition.TemporalPartition.to_dict">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            to_dict
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def to_dict(self):
    return {
        'name': self.name,
        'start': self.active_period.start,
        'end': self.active_period.end,
        'constraint_check': self.constraint_check,
        'self_check': self.self_check,
        'is_catch_all': self.is_catch_all,
        'indexes': [self.index.to_dict()] if self.index else [],
        # todo: single index support for now
    }</code></pre>
         </details>
        </dd>
       </dl>
      </dd>
      <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable">
       <code class="flex name class">
        <span>
         class
         <span class="ident">
          TemporalPartitionedTable
         </span>
        </span>
        <span>
         (
        </span>
        <span>
         name, active_period, partition_field, partitioned_by=week, index_by=None, create_catch_all=True, strict=False)
        </span>
       </code>
      </dt>
      <dd>
       <section class="desc">
        <p>
         Representation of a partitioned by date table.
        </p>
       </section>
       <details class="source">
        <summary>
         <span>
          Expand source code
         </span>
        </summary>
        <pre><code class="python">class TemporalPartitionedTable(PartitionedTable):
    """
    Representation of a partitioned by date table.
    """

    def __init__(
            self, name, active_period, partition_field,
            partitioned_by=PartitionByEnum.w, index_by=None,
            create_catch_all=True, strict=False
    ):
        super().__init__(
            name, partition_field, partitioned_by, index_by, create_catch_all
        )
        self.strict = strict
        self.active_period = active_period
        self._partition_prefix = self.get_partition_prefix()
        self.start_year = self.active_period.start.year

    @property
    def partition_prefix(self):
        """
        The prefix of the partitioned table e.g.
        :return:
        """
        return self._partition_prefix.replace(
            '%year', str(self.active_period.start.year)
        ).replace('%unit', '')

    @property
    def start(self):
        if self.partitions:
            return min(self.partitions).active_period.start
        return self.active_period.start

    @property
    def end(self):
        if self.partitions:
            p = max(self.partitions)
            if p.is_catch_all:
                p = self.partitions[-2]
            return p.active_period.end
        return self.active_period.end

    def self_check(self):
        return TableTools.get_temporal_check(
            self.partition_field,
            self.start,
            self.end,
            new=True
        )

    @property
    def field_value(self) -&gt; str:
        return f'cast(extract({self.partitioned_by} ' \
            f'from NEW.{self.partition_field}) AS TEXT)'

    def get_partition_prefix(self) -&gt; str:
        """
        The table prefix, in the form of:
        table_to_be_partitioned_%unit
        where unit will be replaced by the partition type
        (year, month, week etc)
        :return:
        """
        return f'{self.name}_y%year_{str(self.partitioned_by)[0]}%unit'

    def get_partition_name(self, year, unit) -&gt; str:
        return self._partition_prefix.replace(
            '%year', str(year)
        ).replace(
            '%unit', str(unit)
        )

    def get_partition_range(self) -&gt; dict:
        """
        Return a dict with the date range for the partitions
        e.g.
        for the weekly partition:
         {
            2017: {
                52: TimePeriod instance
            },
            2018: {
                0: TimePeriod instance
            }
        }
        :return:
        :rtype: dict[int][TimePeriod]
        """
        if self.partitioned_by == PartitionByEnum.w:
            return self.active_period.split_by_year_and_week(self.strict)
        elif self.partitioned_by == PartitionByEnum.m:
            return self.active_period.split_by_year_and_month(self.strict)
        else:
            raise ValueError(
                f'Unknown split by option {str(self.partitioned_by)}')

    def partition(self) -&gt; list:
        """
        Partition the table by the partition range
        :return: A list of partitions to be created
        :rtype: list[TemporalPartition]
        """
        for y, units in self.get_partition_range().items():
            for i, tw in units.items():
                self.partitions.append(self.get_partition_for(i, tw, y))
        if self.create_catch_all:
            self.partitions.append(self.get_catch_all_partition())

        return sorted(self.partitions, key=lambda p: p.active_period)

    def get_partition_for(self, unit, tw, year):
        """
        Returns a TemporalPartition for the specific time period (tw) and year
        - given a unit: month | week
        :param str unit: m (for month) or w (for week)
        :param TimePeriod tw:
        :param int year:
        :return:
        :rtype: TemporalPartition
        """
        return TemporalPartition(
            self.get_partition_name(year, unit),
            tw,
            self.partition_field,
            self.index_by
        )

    def get_catch_all_partition(self):
        """
        Create a TemporalPartition that will serve as a catch all partition
        :return:
        :rtype: TemporalPartition
        """
        start = self.end + timedelta(seconds=1)
        end = self.start - timedelta(seconds=1)
        return TemporalPartition(
            self.catch_all_partition_name,
            TimePeriod(start, end),
            self.partition_field,
            self.index_by,
            is_catch_all=True
        )

    def to_dict(self):
        return {
            'name': self.name,
            'partition_prefix': self.partition_prefix,
            'partitions': [p.to_dict() for p in self.partitions],
            'catch_all_partition_name': self.catch_all_partition_name,
            'partitioned_by': str(self.partitioned_by),
            'partition_field': self.partition_field,
            'field_value': self.field_value,
            'self_check': self.self_check()
        }</code></pre>
       </details>
       <h3>
        Ancestors
       </h3>
       <ul class="hlist">
        <li>
         <a href="base.html#baskerville.db.base.PartitionedTable" title="baskerville.db.base.PartitionedTable">
          PartitionedTable
         </a>
        </li>
       </ul>
       <h3>
        Instance variables
       </h3>
       <dl>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.end">
         <code class="name">
          var
          <span class="ident">
           end
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def end(self):
    if self.partitions:
        p = max(self.partitions)
        if p.is_catch_all:
            p = self.partitions[-2]
        return p.active_period.end
    return self.active_period.end</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.field_value">
         <code class="name">
          var
          <span class="ident">
           field_value
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def field_value(self) -&gt; str:
    return f'cast(extract({self.partitioned_by} ' \
        f'from NEW.{self.partition_field}) AS TEXT)'</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.partition_prefix">
         <code class="name">
          var
          <span class="ident">
           partition_prefix
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           The prefix of the partitioned table e.g.
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def partition_prefix(self):
    """
    The prefix of the partitioned table e.g.
    :return:
    """
    return self._partition_prefix.replace(
        '%year', str(self.active_period.start.year)
    ).replace('%unit', '')</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.start">
         <code class="name">
          var
          <span class="ident">
           start
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">@property
def start(self):
    if self.partitions:
        return min(self.partitions).active_period.start
    return self.active_period.start</code></pre>
         </details>
        </dd>
       </dl>
       <h3>
        Methods
       </h3>
       <dl>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.get_catch_all_partition">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_catch_all_partition
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Create a TemporalPartition that will serve as a catch all partition
:return:
:rtype: TemporalPartition
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_catch_all_partition(self):
    """
    Create a TemporalPartition that will serve as a catch all partition
    :return:
    :rtype: TemporalPartition
    """
    start = self.end + timedelta(seconds=1)
    end = self.start - timedelta(seconds=1)
    return TemporalPartition(
        self.catch_all_partition_name,
        TimePeriod(start, end),
        self.partition_field,
        self.index_by,
        is_catch_all=True
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_for">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_partition_for
           </span>
          </span>
          (
          <span>
           self, unit, tw, year)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Returns a TemporalPartition for the specific time period (tw) and year
- given a unit: month | week
:param str unit: m (for month) or w (for week)
:param TimePeriod tw:
:param int year:
:return:
:rtype: TemporalPartition
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_partition_for(self, unit, tw, year):
    """
    Returns a TemporalPartition for the specific time period (tw) and year
    - given a unit: month | week
    :param str unit: m (for month) or w (for week)
    :param TimePeriod tw:
    :param int year:
    :return:
    :rtype: TemporalPartition
    """
    return TemporalPartition(
        self.get_partition_name(year, unit),
        tw,
        self.partition_field,
        self.index_by
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_name">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_partition_name
           </span>
          </span>
          (
          <span>
           self, year, unit)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_partition_name(self, year, unit) -&gt; str:
    return self._partition_prefix.replace(
        '%year', str(year)
    ).replace(
        '%unit', str(unit)
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_prefix">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_partition_prefix
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           The table prefix, in the form of:
table_to_be_partitioned_%unit
where unit will be replaced by the partition type
(year, month, week etc)
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_partition_prefix(self) -&gt; str:
    """
    The table prefix, in the form of:
    table_to_be_partitioned_%unit
    where unit will be replaced by the partition type
    (year, month, week etc)
    :return:
    """
    return f'{self.name}_y%year_{str(self.partitioned_by)[0]}%unit'</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_range">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            get_partition_range
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Return a dict with the date range for the partitions
e.g.
for the weekly partition:
{
2017: {
52: TimePeriod instance
},
2018: {
0: TimePeriod instance
}
}
:return:
:rtype: dict[int][TimePeriod]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def get_partition_range(self) -&gt; dict:
    """
    Return a dict with the date range for the partitions
    e.g.
    for the weekly partition:
     {
        2017: {
            52: TimePeriod instance
        },
        2018: {
            0: TimePeriod instance
        }
    }
    :return:
    :rtype: dict[int][TimePeriod]
    """
    if self.partitioned_by == PartitionByEnum.w:
        return self.active_period.split_by_year_and_week(self.strict)
    elif self.partitioned_by == PartitionByEnum.m:
        return self.active_period.split_by_year_and_month(self.strict)
    else:
        raise ValueError(
            f'Unknown split by option {str(self.partitioned_by)}')</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.partition">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            partition
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Partition the table by the partition range
:return: A list of partitions to be created
:rtype: list[TemporalPartition]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def partition(self) -&gt; list:
    """
    Partition the table by the partition range
    :return: A list of partitions to be created
    :rtype: list[TemporalPartition]
    """
    for y, units in self.get_partition_range().items():
        for i, tw in units.items():
            self.partitions.append(self.get_partition_for(i, tw, y))
    if self.create_catch_all:
        self.partitions.append(self.get_catch_all_partition())

    return sorted(self.partitions, key=lambda p: p.active_period)</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.self_check">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            self_check
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def self_check(self):
    return TableTools.get_temporal_check(
        self.partition_field,
        self.start,
        self.end,
        new=True
    )</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TemporalPartitionedTable.to_dict">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            to_dict
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def to_dict(self):
    return {
        'name': self.name,
        'partition_prefix': self.partition_prefix,
        'partitions': [p.to_dict() for p in self.partitions],
        'catch_all_partition_name': self.catch_all_partition_name,
        'partitioned_by': str(self.partitioned_by),
        'partition_field': self.partition_field,
        'field_value': self.field_value,
        'self_check': self.self_check()
    }</code></pre>
         </details>
        </dd>
       </dl>
      </dd>
      <dt id="baskerville.db.temporal_partition.TimePeriod">
       <code class="flex name class">
        <span>
         class
         <span class="ident">
          TimePeriod
         </span>
        </span>
        <span>
         (
        </span>
        <span>
         start, end, utc=True)
        </span>
       </code>
      </dt>
      <dd>
       <section class="desc">
        <p>
         Extends es_retriever.helpers.time_period.TimePeriod
        </p>
       </section>
       <details class="source">
        <summary>
         <span>
          Expand source code
         </span>
        </summary>
        <pre><code class="python">class TimePeriod(TP):
    """
    Extends es_retriever.helpers.time_period.TimePeriod
    """

    def __init__(self, start, end, utc=True):
        super().__init__(start, end)
        self.utc = utc
        if self.utc:
            self.start = self.start.replace(
                tzinfo=tzutc()
            ).replace(microsecond=0)
            self.end = self.end.replace(
                tzinfo=tzutc()
            ).replace(microsecond=999999)

    def __gt__(self, other):
        return self.start &gt; other.start

    def __ge__(self, other):
        return self.start &gt;= other.start

    def __le__(self, other):
        return self.start &lt;= other.start

    def __lt__(self, other):
        return self.start &lt; other.start

    def split_by_year(self) -&gt; list:
        """
        Splits current time period by year
        :return: a list of time periods, each one of them has a start and end
        in a different year,
         e.g. [ TimePeriod(01-01-2018, 31-12-2018),
                TimePeriod(01-01-2019, 31-01-2019)
            ]
        """
        if self.start.year == self.end.year:
            return [self]

        days_in_year = get_days_in_year(self.start.year)
        start = self.start
        end = start + timedelta(days=days_in_year - start.timetuple().tm_yday)
        sub_periods = []

        while end &lt;= self.end:
            sub_periods.append(TimePeriod(start, end))
            days_in_year = get_days_in_year(start.year)
            start = end
            if start.year == self.end.year:
                end = self.end
            else:
                end = start + timedelta(days=days_in_year)

        return sub_periods

    def split_by_year_and_month(self, strict=False) -&gt; dict:
        """
        Splits the current time period by year and by month.
        E.g.:
        {
            2017: {
                12: TimePeriod instance
            },
            2018: {
                1: TimePeriod instance
            }
        }
        :param bool strict: finish at the end of the month (False), or exactly
        at the end date
        :return:
        """
        days_in_end_month = get_days_in_month(self.end.year, self.end.month)
        start_m = self.start
        end_m = self.end
        if not strict:
            start_m = self.start.replace(day=1, hour=0, minute=0, second=0)
            end_m = self.end.replace(
                day=days_in_end_month,
                hour=23,
                minute=59,
                second=59
            )

        if self.start.year == self.end.year:
            if self.start.month == self.end.month:
                if strict:
                    return {
                        self.start.year: {
                            self.start.month: TimePeriod(
                                start_m,
                                end_m
                            )
                        }
                    }
                return {
                    self.start.year: {self.start.month: self}
                }

        sub_periods = {}

        for year_tw in self.split_by_year():
            y = year_tw.start.year
            m = year_tw.start.month
            days_in_month = get_days_in_month(self.start.year,
                                              self.start.month)
            start = year_tw.start
            end = start.replace(
                day=days_in_month,
                hour=23,
                minute=59,
                second=59,
                microsecond=59
            )
            curr_period = {y: defaultdict(list)}
            for i in range(m, 13):
                curr_period[y][i].append(TimePeriod(start, end))
                start = datetime(y, i, 1, 0, 0, 0, 0).replace(tzinfo=tzutc())
                days_in_month = get_days_in_month(start.year, i)
                if i == self.end.month and strict:
                    end = self.end
                else:
                    end = start.replace(
                        day=days_in_month,
                        hour=23,
                        minute=59,
                        second=59,
                        microsecond=59
                    )
            sub_periods.update(curr_period)

        print(sub_periods)
        return sub_periods

    def split_by_year_and_week(self, strict=False) -&gt; dict:
        """
        Splits the current time period by year and by week.
        E.g.:
        {
            2017: {
                52: TimePeriod instance
            },
            2018: {
                0: TimePeriod instance
            }
        }
        :param bool strict: finish at the end of the week (False), or exactly
        at the end date
        :return:
        """
        sub_periods = {}
        start_y, start_w, _ = self.start.isocalendar()
        end_y, end_w, _ = self.end.isocalendar()

        if start_y == end_y and start_w == end_y:
            if strict:
                return {
                    start_y: {start_w: self}
                }
            else:
                week = isoweek.Week(start_y, start_w)
                start_wd = datetime(*week.monday().timetuple()[:6]).replace(
                    hour=0, minute=0, second=0
                )
                end_wd = datetime(*week.sunday().timetuple()[:6]).replace(
                    hour=23, minute=59, second=59
                )
                return {
                    start_y: {start_w: TimePeriod(
                        start_wd,
                        end_wd
                    )}
                }

        for year_tw in self.split_by_year():
            start_range = 0
            y = year_tw.start.year
            curr_period = {y: defaultdict(list)}
            weeks_in_year = isoweek.Week.last_week_of_year(y).week

            if y == self.end.year and y == end_y:
                weeks_in_year = self.end.isocalendar()[1]

            if y == self.start.year and y == start_y:
                start_range = self.start.isocalendar()[1]

            for w in range(start_range, weeks_in_year + 1):
                week = isoweek.Week(y, w)
                if y == self.start.year and w == start_range and strict:
                    start = self.start
                else:
                    start = datetime(
                        *week.monday().timetuple()[:6]
                    ).replace(hour=0, minute=0, second=0)
                    if y == self.start.year and y == start_y and w == start_range:
                        start = start.replace(
                            hour=self.start.hour,
                            minute=self.start.minute,
                            second=self.start.second
                        )
                if y == self.end.year and w == end_w and strict:
                    end = self.end
                else:
                    end = datetime(
                        *week.sunday().timetuple()[:6]
                    ).replace(hour=23, minute=59, second=59)
                curr_period[y][w] = TimePeriod(start, end)
            sub_periods.update(curr_period)

            if end_y not in sub_periods:
                week = isoweek.Week(end_y, end_w)
                start = datetime(
                    *week.monday().timetuple()[:6]).replace(
                    hour=0, minute=0, second=0
                )
                end = self.end
                if not strict:
                    end = datetime(*week.sunday().timetuple()[:6]).replace(
                        hour=23, minute=59, second=59)
                sub_periods[end_y] = {end_w: TimePeriod(start, end)}

        return sub_periods</code></pre>
       </details>
       <h3>
        Ancestors
       </h3>
       <ul class="hlist">
        <li>
         es_retriever.helpers.time_period.TimePeriod
        </li>
       </ul>
       <h3>
        Methods
       </h3>
       <dl>
        <dt id="baskerville.db.temporal_partition.TimePeriod.split_by_year">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            split_by_year
           </span>
          </span>
          (
          <span>
           self)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Splits current time period by year
:return: a list of time periods, each one of them has a start and end
in a different year,
e.g. [ TimePeriod(01-01-2018, 31-12-2018),
TimePeriod(01-01-2019, 31-01-2019)
]
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def split_by_year(self) -&gt; list:
    """
    Splits current time period by year
    :return: a list of time periods, each one of them has a start and end
    in a different year,
     e.g. [ TimePeriod(01-01-2018, 31-12-2018),
            TimePeriod(01-01-2019, 31-01-2019)
        ]
    """
    if self.start.year == self.end.year:
        return [self]

    days_in_year = get_days_in_year(self.start.year)
    start = self.start
    end = start + timedelta(days=days_in_year - start.timetuple().tm_yday)
    sub_periods = []

    while end &lt;= self.end:
        sub_periods.append(TimePeriod(start, end))
        days_in_year = get_days_in_year(start.year)
        start = end
        if start.year == self.end.year:
            end = self.end
        else:
            end = start + timedelta(days=days_in_year)

    return sub_periods</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TimePeriod.split_by_year_and_month">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            split_by_year_and_month
           </span>
          </span>
          (
          <span>
           self, strict=False)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Splits the current time period by year and by month.
E.g.:
{
2017: {
12: TimePeriod instance
},
2018: {
1: TimePeriod instance
}
}
:param bool strict: finish at the end of the month (False), or exactly
at the end date
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def split_by_year_and_month(self, strict=False) -&gt; dict:
    """
    Splits the current time period by year and by month.
    E.g.:
    {
        2017: {
            12: TimePeriod instance
        },
        2018: {
            1: TimePeriod instance
        }
    }
    :param bool strict: finish at the end of the month (False), or exactly
    at the end date
    :return:
    """
    days_in_end_month = get_days_in_month(self.end.year, self.end.month)
    start_m = self.start
    end_m = self.end
    if not strict:
        start_m = self.start.replace(day=1, hour=0, minute=0, second=0)
        end_m = self.end.replace(
            day=days_in_end_month,
            hour=23,
            minute=59,
            second=59
        )

    if self.start.year == self.end.year:
        if self.start.month == self.end.month:
            if strict:
                return {
                    self.start.year: {
                        self.start.month: TimePeriod(
                            start_m,
                            end_m
                        )
                    }
                }
            return {
                self.start.year: {self.start.month: self}
            }

    sub_periods = {}

    for year_tw in self.split_by_year():
        y = year_tw.start.year
        m = year_tw.start.month
        days_in_month = get_days_in_month(self.start.year,
                                          self.start.month)
        start = year_tw.start
        end = start.replace(
            day=days_in_month,
            hour=23,
            minute=59,
            second=59,
            microsecond=59
        )
        curr_period = {y: defaultdict(list)}
        for i in range(m, 13):
            curr_period[y][i].append(TimePeriod(start, end))
            start = datetime(y, i, 1, 0, 0, 0, 0).replace(tzinfo=tzutc())
            days_in_month = get_days_in_month(start.year, i)
            if i == self.end.month and strict:
                end = self.end
            else:
                end = start.replace(
                    day=days_in_month,
                    hour=23,
                    minute=59,
                    second=59,
                    microsecond=59
                )
        sub_periods.update(curr_period)

    print(sub_periods)
    return sub_periods</code></pre>
         </details>
        </dd>
        <dt id="baskerville.db.temporal_partition.TimePeriod.split_by_year_and_week">
         <code class="name flex">
          <span>
           def
           <span class="ident">
            split_by_year_and_week
           </span>
          </span>
          (
          <span>
           self, strict=False)
          </span>
         </code>
        </dt>
        <dd>
         <section class="desc">
          <p>
           Splits the current time period by year and by week.
E.g.:
{
2017: {
52: TimePeriod instance
},
2018: {
0: TimePeriod instance
}
}
:param bool strict: finish at the end of the week (False), or exactly
at the end date
:return:
          </p>
         </section>
         <details class="source">
          <summary>
           <span>
            Expand source code
           </span>
          </summary>
          <pre><code class="python">def split_by_year_and_week(self, strict=False) -&gt; dict:
    """
    Splits the current time period by year and by week.
    E.g.:
    {
        2017: {
            52: TimePeriod instance
        },
        2018: {
            0: TimePeriod instance
        }
    }
    :param bool strict: finish at the end of the week (False), or exactly
    at the end date
    :return:
    """
    sub_periods = {}
    start_y, start_w, _ = self.start.isocalendar()
    end_y, end_w, _ = self.end.isocalendar()

    if start_y == end_y and start_w == end_y:
        if strict:
            return {
                start_y: {start_w: self}
            }
        else:
            week = isoweek.Week(start_y, start_w)
            start_wd = datetime(*week.monday().timetuple()[:6]).replace(
                hour=0, minute=0, second=0
            )
            end_wd = datetime(*week.sunday().timetuple()[:6]).replace(
                hour=23, minute=59, second=59
            )
            return {
                start_y: {start_w: TimePeriod(
                    start_wd,
                    end_wd
                )}
            }

    for year_tw in self.split_by_year():
        start_range = 0
        y = year_tw.start.year
        curr_period = {y: defaultdict(list)}
        weeks_in_year = isoweek.Week.last_week_of_year(y).week

        if y == self.end.year and y == end_y:
            weeks_in_year = self.end.isocalendar()[1]

        if y == self.start.year and y == start_y:
            start_range = self.start.isocalendar()[1]

        for w in range(start_range, weeks_in_year + 1):
            week = isoweek.Week(y, w)
            if y == self.start.year and w == start_range and strict:
                start = self.start
            else:
                start = datetime(
                    *week.monday().timetuple()[:6]
                ).replace(hour=0, minute=0, second=0)
                if y == self.start.year and y == start_y and w == start_range:
                    start = start.replace(
                        hour=self.start.hour,
                        minute=self.start.minute,
                        second=self.start.second
                    )
            if y == self.end.year and w == end_w and strict:
                end = self.end
            else:
                end = datetime(
                    *week.sunday().timetuple()[:6]
                ).replace(hour=23, minute=59, second=59)
            curr_period[y][w] = TimePeriod(start, end)
        sub_periods.update(curr_period)

        if end_y not in sub_periods:
            week = isoweek.Week(end_y, end_w)
            start = datetime(
                *week.monday().timetuple()[:6]).replace(
                hour=0, minute=0, second=0
            )
            end = self.end
            if not strict:
                end = datetime(*week.sunday().timetuple()[:6]).replace(
                    hour=23, minute=59, second=59)
            sub_periods[end_y] = {end_w: TimePeriod(start, end)}

    return sub_periods</code></pre>
         </details>
        </dd>
       </dl>
      </dd>
     </dl>
    </section>
   </article>
   <nav id="sidebar">
    <h1>
     Index
    </h1>
    <div class="toc">
     <ul>
     </ul>
    </div>
    <ul id="index">
     <li>
      <h3>
       Super-module
      </h3>
      <ul>
       <li>
        <code>
         <a href="index.html" title="baskerville.db">
          baskerville.db
         </a>
        </code>
       </li>
      </ul>
     </li>
     <li>
      <h3>
       <a href="#header-classes">
        Classes
       </a>
      </h3>
      <ul>
       <li>
        <h4>
         <code>
          <a href="#baskerville.db.temporal_partition.TemporalPartition" title="baskerville.db.temporal_partition.TemporalPartition">
           TemporalPartition
          </a>
         </code>
        </h4>
        <ul class="">
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartition.constraint_check" title="baskerville.db.temporal_partition.TemporalPartition.constraint_check">
            constraint_check
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartition.index" title="baskerville.db.temporal_partition.TemporalPartition.index">
            index
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartition.self_check" title="baskerville.db.temporal_partition.TemporalPartition.self_check">
            self_check
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartition.to_dict" title="baskerville.db.temporal_partition.TemporalPartition.to_dict">
            to_dict
           </a>
          </code>
         </li>
        </ul>
       </li>
       <li>
        <h4>
         <code>
          <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable" title="baskerville.db.temporal_partition.TemporalPartitionedTable">
           TemporalPartitionedTable
          </a>
         </code>
        </h4>
        <ul class="">
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.end" title="baskerville.db.temporal_partition.TemporalPartitionedTable.end">
            end
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.field_value" title="baskerville.db.temporal_partition.TemporalPartitionedTable.field_value">
            field_value
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.get_catch_all_partition" title="baskerville.db.temporal_partition.TemporalPartitionedTable.get_catch_all_partition">
            get_catch_all_partition
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_for" title="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_for">
            get_partition_for
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_name" title="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_name">
            get_partition_name
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_prefix" title="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_prefix">
            get_partition_prefix
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_range" title="baskerville.db.temporal_partition.TemporalPartitionedTable.get_partition_range">
            get_partition_range
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.partition" title="baskerville.db.temporal_partition.TemporalPartitionedTable.partition">
            partition
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.partition_prefix" title="baskerville.db.temporal_partition.TemporalPartitionedTable.partition_prefix">
            partition_prefix
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.self_check" title="baskerville.db.temporal_partition.TemporalPartitionedTable.self_check">
            self_check
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.start" title="baskerville.db.temporal_partition.TemporalPartitionedTable.start">
            start
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TemporalPartitionedTable.to_dict" title="baskerville.db.temporal_partition.TemporalPartitionedTable.to_dict">
            to_dict
           </a>
          </code>
         </li>
        </ul>
       </li>
       <li>
        <h4>
         <code>
          <a href="#baskerville.db.temporal_partition.TimePeriod" title="baskerville.db.temporal_partition.TimePeriod">
           TimePeriod
          </a>
         </code>
        </h4>
        <ul class="">
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TimePeriod.split_by_year" title="baskerville.db.temporal_partition.TimePeriod.split_by_year">
            split_by_year
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TimePeriod.split_by_year_and_month" title="baskerville.db.temporal_partition.TimePeriod.split_by_year_and_month">
            split_by_year_and_month
           </a>
          </code>
         </li>
         <li>
          <code>
           <a href="#baskerville.db.temporal_partition.TimePeriod.split_by_year_and_week" title="baskerville.db.temporal_partition.TimePeriod.split_by_year_and_week">
            split_by_year_and_week
           </a>
          </code>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ul>
   </nav>
  </main>
  <footer id="footer">
   <p>
    Generated by
    <a href="https://pdoc3.github.io/pdoc">
     <cite>
      pdoc
     </cite>
     0.7.2
    </a>
    .
   </p>
   <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">
    <img alt="Creative Commons Licence" src="https://i.creativecommons.org/l/by/4.0/80x15.png" style="border-width:0"/>
   </a>
   <br/>
   This work is copyright (c) 2020, eQualit.ie inc., and is licensed under a
   <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">
    Creative Commons Attribution 4.0 International License
   </a>
   .
  </footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad()
  </script>
 </body>
</html>